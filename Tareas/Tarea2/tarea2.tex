\documentclass[spanish,12pt,letterpaper]{article}

\usepackage[english]{babel}
\usepackage[table]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{authblk}
\usepackage{csquotes}
\usepackage{enumerate}
\usepackage{float}
\usepackage{forest}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

\lstset{style=mystyle}

\title{Programación declarativa. Tarea 2\\
\Huge{The Imperative is Dark and Full of Terrors}}
\author{Juan Alfonso Garduño Solís\\
  Emiliano Galeana Araujo}
\affil{Facultad de ciencias, UNAM}
\date{Fecha de entrega: Lunes 24 de febrero de 2020}

\begin{document}

\maketitle

\section{Demostraciones de propiedades}
\begin{itemize}
\item
  \begin{lstlisting}[language=Haskell]
    sum . map double = double . sum
  \end{lstlisting}
  
\item
  \begin{lstlisting}[language=Haskell]
    sum . map sum = sum . concat
  \end{lstlisting}
  
\item
  \begin{lstlisting}[language=Haskell]
    sum . sort = sum
  \end{lstlisting}
\end{itemize}
Donde, \texttt{double} se define de la siguiente manera:
\begin{lstlisting}[language=Haskell]
  double :: Integer -> Integer
  double x = 2 * x
\end{lstlisting}
Y, \texttt{sum},\texttt{map},\texttt{sort} y \texttt{concat} son las definidas en
el \texttt{Prelude}, de Haskell.

\section{Función take}
En Haskell la función \texttt{take n} toma los primeros n elementos de una lista,
mientras que \texttt{drop n} regresa la lista sin los primeros n elementos de
esta. Demuesrta o da un contraejemplo:
\begin{itemize}
\item
  \begin{lstlisting}[language=Haskell]
    take n xs ++ drop n xs = xs
  \end{lstlisting}

\item
  \begin{lstlisting}[language=Haskell]
    take m . take n = take (min m n)
  \end{lstlisting}
  
\item
  \begin{lstlisting}[language=Haskell]
    map f . take n = take n . map f
  \end{lstlisting}
  
\item
  \begin{lstlisting}[language=Haskell]
    filter p . concat = concat . map (filter p)
  \end{lstlisting}
\end{itemize}

\section{Función map}
Consideremos la siguiente afirmación
\begin{lstlisting}[language=Haskell]
  map (f . g) xs = map f $ map g xs
\end{lstlisting}
\begin{enumerate}[(a)]
\item ¿Se cumple para cualquier xs? Si es cierta bosqueja la demostración, en
  caso contrario, ¿Qué condiciones se deben pedir sobre xs para que sea cierta?
\item Intuitivamente, ¿Qué lado de la igualdad resulta más eficiente? ¿Esto es
  cierto incluso en lenguajes con evaluación perezosa? Justifica tu respuesta.
\end{enumerate}

\end{document}
