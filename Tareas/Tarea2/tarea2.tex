\documentclass[spanish,12pt,letterpaper]{article}

\usepackage[english]{babel}
\usepackage[table]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{authblk}
\usepackage{csquotes}
\usepackage{enumerate}
\usepackage{float}
\usepackage{forest}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

\lstset{style=mystyle}

\title{Programación declarativa. Tarea 2\\
\Huge{The Imperative is Dark and Full of Terrors}}
\author{Juan Alfonso Garduño Solís\\
  Emiliano Galeana Araujo}
\affil{Facultad de ciencias, UNAM}
\date{Fecha de entrega: Lunes 24 de febrero de 2020}

\begin{document}

\maketitle

\section{Demostraciones de propiedades}
\begin{itemize}
\item
  \begin{lstlisting}[language=Haskell]
    sum . map double = double . sum
  \end{lstlisting}
  \begin{itemize}
    \item Caso base:
    \begin{lstlisting}[language=Haskell]
      sum . map double [] = double . sum []
      sum . 0 = double . sum []
      0 = double . sum []
      sum [] = double sum []
      double . sum [] = double . sum []
    \end{lstlisting}
  \item Hipótesis
    \begin{lstlisting}[language=Haskell]
      sum . map double xs = double . sum xs
    \end{lstlisting}
  \item Paso inductivo
    \begin{itemize}
    \item [--] Por demostrar
      \begin{lstlisting}[language=Haskell]
        sum . map double (x:xs) = double . sum (x:xs)
      \end{lstlisting}
    \end{itemize}
    \begin{lstlisting}[language=Haskell]
      sum . map double (x:xs) = double . sum (x:xs)
      -- Definicion de aplicar double a la cabeza de x:xs.
      sum . [double x] ++ map double xs = double . sum (x:xs)
      -- Definicion de aplicar sum ([double x] es igual a [2*x]).
      2*x + sum . map double xs = double . sum (x:xs)
      -- Hipotesis.
      2*x + double . sum xs = double . sum (x:xs)
      -- Defincion de double inversa.
      double x + sum xs = double . sum (x:xs)
      -- Metemos x a la funcion sum.
      double . sum (x:xs) = double . sum (x:xs)
    \end{lstlisting}
  \end{itemize}
  
\item
  \begin{lstlisting}[language=Haskell]
    sum . map sum = sum . concat
  \end{lstlisting}
  \begin{itemize}
    \item Caso base:
    \begin{lstlisting}[language=Haskell]
      sum . map sum [] = sum . concat []
      sum [] = sum . concat []
      0 = sum . concat []
      sum [] = sum . concat []
      sum . concat [] = sum . concat []
    \end{lstlisting}
  \item Hipótesis
    \begin{lstlisting}[language=Haskell]
      sum . map sum xs = sum . concat xs
    \end{lstlisting}
  \item Paso inductivo
    \begin{itemize}
    \item [--] Por demostrar
      \begin{lstlisting}[language=Haskell]
        sum . map sum (x:xs) = sum . concat (x:xs)
      \end{lstlisting}
    \end{itemize}
    \begin{lstlisting}[language=Haskell]
      sum . map sum (x:xs) = sum . concat (x:xs)
      -- Defincion de aplicar map sum a la cabeza de x:xs. Definimos sum' x como
      el resultado de sum x.
      sum [sum' x] . map sum xs = sum . concat (x:xs)
      -- Definicion de aplicar sum a una lista con un elemento (sum' x).
      (sum' x) + sum . map xs = sum . concat (x:xs)
      -- Hipotesis.
      (sum' x) + sum . concat (xs) = sum . concat (x:xs)
      -- Metemos la suma a la funcion sum.
      sum [sum' x] . concat (xs) = sum . concat (x:xs)
      -- Como [sum' x] es el resultado de la aplicar sum a la lista x. Siendo x
      una lista, podemos hacer lo siguiente.
      sum . concat (x:xs) = sum . concat (x:xs)
    \end{lstlisting}
  \end{itemize}

\item
  \begin{lstlisting}[language=Haskell]
    sum . sort = sum
  \end{lstlisting}
  \begin{itemize}
    \item Caso base:
    \begin{lstlisting}[language=Haskell]
      sum . sort [] = sum []
      sum [] = sum []
    \end{lstlisting}
  \item Hipótesis
    \begin{lstlisting}[language=Haskell]
      sum . sort xs = sum xs
    \end{lstlisting}
  \item Paso inductivo
    \begin{itemize}
    \item [--] Por demostrar
      \begin{lstlisting}[language=Haskell]
        sum . sort (x:xs) = sum (x:xs)
        -- Ordenar la cola de una lista y luego ordenar la cola (ordenada)
        concatenada a la cabeza es lo mismo que ordenar toda la lista.
        sum [x] ++ sort xs = sum (x:xs)
        -- Definicion de sum.
        x + sum . sort xs = sum (x:xs)
        -- Hipotesis.
        x + sum xs = sum (x:xs)
        -- Definicion inversa de sum.
        sum [x]++xs = sum (x:xs)
        -- Definicion de concatenar.
        sum (x:xs) = sum (x:xs)
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
  
\end{itemize}
Donde, \texttt{double} se define de la siguiente manera:
\begin{lstlisting}[language=Haskell]
  double :: Integer -> Integer
  double x = 2 * x
\end{lstlisting}
Y, \texttt{sum},\texttt{map},\texttt{sort} y \texttt{concat} son las definidas en
el \texttt{Prelude}, de Haskell.

\section{Función take}
En Haskell la función \texttt{take n} toma los primeros n elementos de una lista,
mientras que \texttt{drop n} regresa la lista sin los primeros n elementos de
esta. Demuesrta o da un contraejemplo:
\begin{itemize}
\item
  \begin{lstlisting}[language=Haskell]
    take n xs ++ drop n xs = xs
  \end{lstlisting}

\item
  \begin{lstlisting}[language=Haskell]
    take m . take n = take (min m n)
  \end{lstlisting}
  
\item
  \begin{lstlisting}[language=Haskell]
    map f . take n = take n . map f
  \end{lstlisting}
  
\item
  \begin{lstlisting}[language=Haskell]
    filter p . concat = concat . map (filter p)
  \end{lstlisting}
\end{itemize}

\section{Función map}
Consideremos la siguiente afirmación
\begin{lstlisting}[language=Haskell]
  map (f . g) xs = map f $ map g xs
\end{lstlisting}
\begin{enumerate}[(a)]
\item ¿Se cumple para cualquier xs? Si es cierta bosqueja la demostración, en
  caso contrario, ¿Qué condiciones se deben pedir sobre xs para que sea cierta?
\item Intuitivamente, ¿Qué lado de la igualdad resulta más eficiente? ¿Esto es
  cierto incluso en lenguajes con evaluación perezosa? Justifica tu respuesta.
\end{enumerate}

\end{document}
